import pandas as pd
import numpy as np
import trackpy as tp
import csv
import matplotlib.pyplot as plt
from matplotlib import cm
import pdb
import os
import colorsys
from matplotlib.colors import ListedColormap
import matplotlib as mpl
import math
import time
from preproc import preproc


def find_contact_frame(df_frame, distance=20):
    length = len(df_frame)
    dt = np.zeros((length, length))
    X = np.asarray(df_frame.X)
    Y = np.asarray(df_frame.Y)
    pNo = np.asarray(df_frame.particle)
    for i in range(length):
        for j in range(i+1):
            x = X[i] - X[j]
            y = Y[i] - Y[j]
            dt[j, i] = (x**2 + y**2)**.5
    dt[dt == 0] = np.nan
    ind = np.where(dt<distance)
    ind_list = []
    if len(ind[0]) > 0:
        for i in range(len(ind[0])):
            # pdb.set_trace()
            ind_list.append((pNo[ind[0][i]],pNo[ind[1][i]]))
    # return a list of particle numbers as a tuple [(),(),...]
        return ind_list
    else:
        return ind_list

def find_contact(df, distance=20):     
    # within a frame, find pairs whose distances are smaller than 20 px
    ind_list = pd.DataFrame(columns=['frame', 'p1', 'p2'])
    for i in range(df.Slice.max()):
        frameNo = int(i+1)
        frame = df.where(df.Slice==frameNo).dropna()
        ind = find_contact_frame(frame, distance)
        if ind:
            for pair in ind:
                data = np.array([[frameNo, pair[0], pair[1]]])
                header = ['frame', 'p1', 'p2']
                frameContact = pd.DataFrame(data=data, columns=header)
                ind_list = ind_list.append(frameContact)
    return ind_list

def get_traj(df, pNo, frameNo):
    df = df.where(df.Slice>=frameNo[0]).dropna()
    df = df.where(df.Slice<frameNo[1]).dropna()
    traj = pd.DataFrame()
    for No in pNo:
        traj = traj.append(df.where(df.particle==No).dropna())
    return traj

def contact_traj():
    ldfDir = r'G:\Data(2019)\07142019\03\tracking.csv'    
    linkdf = pd.read_csv(ldfDir)
    frameNo = (130, 180)
    t20 = get_traj(linkdf, (22,), frameNo)
    tp.plot_traj(t20, t_column='Slice', pos_columns=['X', 'Y'])
    contact_traj = r'G:\Data(2019)\07142019\03\contact_traj.csv'
    t20.to_csv(contact_traj, index=True)


    

def cal_vel_contact_traj():
    traj = pd.read_csv(r'G:\Data(2019)\07142019\03\contact_traj.csv')
    pairs = traj.pair.drop_duplicates()
    traj_v = pd.DataFrame()
    for i in pairs:
        traj1 = traj.where(traj.pair==i).dropna()
        traj1 = traj1.assign(v=0)
        
        pNo = traj1.particle.drop_duplicates().to_list()
        
        traj11 = traj1.where(traj1.particle==pNo[0]).dropna()
        traj12 = traj1.where(traj1.particle==pNo[1]).dropna()
        min1 = traj11.Slice.min()
        max1 = traj11.Slice.max()
        
        for num, slice in enumerate(traj11.Slice):
            if num == len(traj11.Slice) - 1:
                traj11.iloc[num]['v'] = traj11.iloc[num-1]['v']
                break
            x = traj11.iloc[num+1]['X'] - traj11.iloc[num]['X']
            y = traj11.iloc[num+1]['Y'] - traj11.iloc[num]['Y']
            dist = (x**2 + y**2)**.5
            t = traj11.iloc[num+1]['Slice'] - traj11.iloc[num]['Slice']
            traj11.iloc[num]['v'] = dist/t
        
        for num, slice in enumerate(traj12.Slice):
            if num == len(traj12.Slice) - 1:
                traj12.iloc[num]['v'] = traj12.iloc[num-1]['v']
                break
            x = traj12.iloc[num+1]['X'] - traj12.iloc[num]['X']
            y = traj12.iloc[num+1]['Y'] - traj12.iloc[num]['Y']
            dist = (x**2 + y**2)**.5
            t = traj12.iloc[num+1]['Slice'] - traj12.iloc[num]['Slice']
            traj12.iloc[num]['v'] = dist/t
        
        traj_v = traj_v.append(traj11)
        traj_v = traj_v.append(traj12)
    traj_v.to_csv(r'G:\Data(2019)\07142019\03\pair_vel.csv', index=False)
    
def proc_traj(traj, interval=1):
    """
    Calculate the velocity and the distance from the closest neighbor of all particles in 
    each frame. Other quantities may also be calculated but they haven't been implemented.
    ---
    *args
        traj ... trajectory pd.DataFrame object generated by trackpy link function. It should
                at least have columns ['X', 'Y', 'Slice'('frame'), 'particle']
        interval ... the interval used to evaluate the velocity of particles. Defaults to 1
                    which means evaluating velocity each frame. Longer interval in general 
                    gives rise to smoother velocity profile, and shorter interval usually 
                    captures transient velocity variation better.
    Return
        traj_new ... a new trajectory pd.DataFrame object. It retains all the columns in traj, 
                    the original input trajectory data, and adds ['dx', 'dy', 'pAngle', 'dist',
                    'collision_angle'] to it.
                    ---
                    dx ... x displacement happens during time interval (X.diff(interval))
                    dy ... y displacement happens during time interval (Y.diff(interval))
                    pAngle ... the polar angle of particles, evaluated from the nematic angle 
                                and the velocity.
                    dist ... distance from the nearest neighbor
                    collision angle ... difference between the polar angles of a particle and 
                                        its nearest neighbor.    
    """
    def cal_v(traj, interval):
        disp_x = traj1.X.diff(periods=interval)
        disp_y = traj1.Y.diff(periods=interval)
        dt = traj1.Slice.diff(periods=interval)
        disp = (disp_x**2+disp_y**2)**.5
        v = disp/dt
        return disp_x, disp_y, v

    traj.sort_values(['Slice', 'particle'], inplace=True)
    # framewise_data = []
    # individual_traj = pd.DataFrame()
    # for frameNo in traj.Slice.drop_duplicates():
        # framewise_data.append(traj.where(traj.Slice==frameNo).dropna(how='all'))
    traj_new = pd.DataFrame()
    for pNo in traj.particle.drop_duplicates():
        traj1 = traj.loc[traj.particle==pNo]
        dx, dy, v = cal_v(traj1, interval)
        # pAngle = cal_polar_angle(traj1.Angle, dy)
        pAngle = dy/dy.abs()*traj1.Angle
        traj1 = traj1.assign(dx=dx, dy=dy, v=v, pAngle=pAngle, dist=0, collision_angle=0)
        traj_new = traj_new.append(traj1, ignore_index=True)
        # find distance from closest neighbor in each frame

    count = 0
    for num, particle in traj_new.iterrows():
        frameData = traj_new.loc[traj_new.Slice==particle.Slice]
        dx = frameData.X - particle.X
        dy = frameData.Y - particle.Y
        angle = frameData.pAngle
        dist=(dx**2 + dy**2)**.5
        tmp_table = dx.to_frame().assign(Y=dy, pAngle=angle, dist=dist).sort_values(by=['dist'])
        try:
            traj_new.dist.iloc[count] = tmp_table.dist.iloc[1]
            traj_new.collision_angle.iloc[count] = abs(tmp_table.pAngle.iloc[1] - particle.pAngle) 
        except:
            traj_new.dist.iloc[count] = np.nan
            traj_new.collision_angle.iloc[count] = np.nan                
        count += 1
    return traj_new

def dirrec(path, filename):
    """
    Recursively look for all the directories of files with name <filename>.
    ---
    *args
        path ... the directory where you want to look for files.
        filename ... name of the files you want to look for.
    Return
        dirList ... a list of full directories of files with name <filename>
    Note
        <filename> can be partially specified, e.g. '*.py' to search for all the 
        .py files or 'track*' to search for all files starting with 'track'.
    """
    dirList = []
    for r, d, f in os.walk(path):
        for dir in d:
            tmp = dirrec(dir, filename)
            if tmp:
                dirList.append(tmp)
        for file in f:
            if filename.startswith('*'):
                if file.endswith(filename[1:]):
                    dirList.append(os.path.join(r, file))
            elif filename.endswith('*'):
                if file.startswith(filename[:-1]):
                    dirList.append(os.path.join(r, file))
            elif file == filename:
                dirList.append(os.path.join(r, file))            
    return dirList
    
def postproc(imgDir):
    """
    Process the particle finding result from preproc function.    
    ---
    *args
        imgDir ... A full directory of a particle finding result file finding.csv
    Process
        1 ... Link particle finding results into trajectories (using algorithm from trackpy package).
        Results are saved in tracking.csv
        2 ... Analyze the trajectories, calculating the velocity, distance from the nearest neighbor
        and collision angle for each particle. Results are saved in v_dist.csv
    """
    folder, file = os.path.split(imgDir)
    if os.path.exists(os.path.join(folder, 'tracking.csv')) and \
        os.path.exists(os.path.join(folder, 'v_dist_5.csv')):
        print('Images in ' + folder + ' has already been post-processed.')
        return
    folder, file = os.path.split(imgDir)
    data = pd.read_csv(os.path.join(folder, 'finding.csv'))
    traj_raw = tp.link_df(data, 15, memory=5, pos_columns=['X', 'Y'], t_column='Slice')
    traj_raw.rename(mapper={'Slice': 'frame'}, axis=1, inplace=True)
    traj = tp.filter_stubs(traj_raw, threshold=60)
    traj.rename(mapper={'frame': 'Slice'}, axis=1, inplace=True)
    traj.to_csv(os.path.join(folder, 'tracking.csv'), index=False)
    print('Calculating collision events ...')
    traj_p = proc_traj(traj, interval=5)
    traj_p.to_csv(os.path.join(folder, 'v_dist_5.csv'), index=False)

def visualize_data():
    dataDir = r'F:\Data(2019)\07152019\15\v_dist.csv'
    data = pd.read_csv(dataDir).dropna()
    x = data.dist
    y = data.v
    CA = data.collision_angle    
    CA.loc[CA>180] = 360 - CA.loc[CA>180]    
    CA = CA/180
    colors = []
    for color in CA:
        colors.append(math.floor(color*255))
    norm = mpl.colors.Normalize(vmin=0, vmax=180)    
    viridis = cm.get_cmap('viridis', 256)    
    plt.scatter(x, y, c=colors, cmap=viridis, s=2, norm=norm)    
    plt.colorbar()
    plt.show()
def batch_proc():
    dirList = dirrec(r'F:\Data(2019)\07142019', 'processed_img.tif')
    for imgDir in dirList:
        preproc(imgDir)
        postproc(imgDir)
def cal_hist_in_different_ranges(*args):
    """
    Calculate the histogram of a list of data in different variable ranges.
    ---
    *args
        x ... args[0]: an array like object, representing the independent variable
        y ... args[1]: an array like object, representing the dependent variable
        NoB ... args[2]: elements in x are divided in multiple bins. NoB specify the
                        total number of bins.
    Return
        A pandas.DataFrame object with columns ['bin', 'hist', 'xbin_1', 'xbin_2']
        bin ... list of the centers of y bin
        hist ... histogram values corresponding to each y bin
        xbin_1 ... left edge of xbin_1
        xbin_2 ... right edge of xbin_2
    Example
        data = np.random.rand(100, 2)
        data = pd.DataFrame(data=data, columns=['X', 'Y'])
        NoB = 5
        cal_hist_in_different_ranges(data.X, data.Y, NoB) 
    """
    def binEdge(x, NoB):
        binEdge = []
        binsize = (x.max() - x.min()) / NoB
        for i in range(NoB):
            if i == NoB-1:
                bin_edge = ( x.min()+(NoB-1)*binsize, x.max() )
            else:
                bin_edge = ( x.min()+i*binsize, x.min()+(i+1)*binsize )
            binEdge.append(bin_edge)
        return binEdge
    x = args[0]
    y = args[1]
    NoB = args[2]
    bin_edges = binEdge(x, NoB)
    toSave = pd.DataFrame()
    for bin_edge in bin_edges:
        ydata = y[(x>=bin_edge[0]) & (x<bin_edge[1])]
        yhist, ybin_edges = np.histogram(np.array(ydata), bins=10, density='True')
        bin_c = []
        for i in range(len(ybin_edges)-1):
            bin_c.append((ybin_edges[i]+ybin_edges[i+1])/2)
        bin_c = np.array(bin_c).reshape(len(bin_c), 1)
        yhist = np.array(yhist).reshape(len(yhist), 1)
        data = np.concatenate((bin_c, yhist), axis=1)
        tmp = pd.DataFrame(data=data, columns=['bin', 'hist'])
        tmp = tmp.assign(xbin_1=bin_edge[0], xbin_2=bin_edge[1])
        toSave = toSave.append(tmp)
    return toSave
    # toSave.to_csv(os.path.join(r'I:\Google Drive\Code\Python\Particle-tracking\bacTrack', 'hist_data.csv'))

if __name__ == '__main__': 
    dataDir = r'F:\Data(2019)\07142019\11\v_dist_5.csv'
    data = pd.read_csv(dataDir).dropna()
    
    x = data.loc[data.v>2, 'dist']
    y = data.loc[data.v>2, 'v']
    NoB = 5
    hist_data = cal_hist_in_different_ranges(x, y, NoB)
    bin1 = hist_data.xbin_1.drop_duplicates()
    cmap = cm.get_cmap('Set1')
    color_ind = np.linspace(0, 1, NoB)
    count = 0
    for bins in bin1:        
        x = hist_data.loc[hist_data.xbin_1==bins, 'bin']        
        y = hist_data.loc[hist_data.xbin_1==bins, 'hist']
        bin_size = x[1] - x[0]
        # if count == 0 or count == 5:
        plt.plot(x, y*bin_size, 'o', color = cmap(color_ind[count]))
        # plt.xscale('log')        
        plt.yscale('log')
        count += 1

    plt.show()   
    
    